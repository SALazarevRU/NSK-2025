




Для статического сайта на GitHub Pages (где нет PHP, Node.js и базы данных) остаются два надёжных способа отправки писем:

1. Бесплатный «однострочник» через Formspree
(или аналоги: Getform, Formsubmit, Basin — принцип одинаков)



2. Серверлесс-функция через GitHub Actions + Email-сервис
Если нужен полный контроль (кастомные шаблоны, whitelist, логи), но хостинг остаётся статическим:

А. Делаем функцию-«заглушку» на любом serverless-хостинге (Netlify Functions, Vercel Functions, Cloudflare Workers) – они бесплатны в малых объёмах.
Б. Внутри функции используем любой SMTP-транспорт (Yandex, Gmail, Mailgun).
В. В HTML форма POST-ит на URL этой функции.

Краткий пример для Netlify:

В репозитории создаёте папку /netlify/functions/mail.js (статьи и шаблоны в интернете полны готовых кусков кода).

В форме action="/.netlify/functions/mail".

Коммитите — Netlify автоматически деплоит и функцию, и статику.

Плюс: 125 000 вызовов/мес бесплатно, можно ставить CORS, секретные ключи хранятся в переменных окружения.
Минус: нужно 10-15 минут на первую настройку.













Следить ≠ заставлять посетителя писать «правильно», а автоматически проверять его ввод доскладки и, при обнаружении «строго-запрещённого», либо:

сразу блокировать отправку (показывать ошибку), либо

тихо заменять/удалять триггер-слова, чтобы Formspree их не увидел.

Ниже два рабочих способа «следить» без участия человека.

Стоп-лист на клиенте (лёгкий)

Добавьте в JS-обработчик перед сбором FormData:

js
const blockWords = ['viagra','casino','купить viagra','xxx','долларов за','биткойн','https://bit.ly'];
const userText = (form.comment.value + form.subject.value).toLowerCase();
if (blockWords.some(w => userText.includes(w))) {
  msg.innerHTML = '<p style="color:red">Сообщение содержит запрещённые слова. Пожалуйста, переформулируйте.</p>';
  return;          // письмо не уходит
}
«Мягкая» чистка (никто не увидит)

Создайте «чистую» копию текста, убирая всё опасное, и уже её кладите в FormData:

js
function clean(text){
  return text
    .replace(/(?:viagra|xxx|купить\s+(?:viagra|cialis))/gi,'***')
    .replace(/https?:\/\/bit\.ly\/\S+/gi,'[url]')
    .trim();
}
data.set('comment', clean(form.comment.value));
data.set('subject', clean(form.subject.value));
(остальные поля без изменений.)

Доп.фильтры, которые уменьшат «спам-скор»

Минимальная длина сообщения:

js
if (form.comment.value.trim().length < 10) { /* ошибка */ }
Запрет одинаковых цифр (111111) / caps-only строк:

js
if (/^(.)\1{5,}$/i.test(form.comment.value)) { /* ошибка */ }
Если есть подозрительная ссылка — разбивайте точками h t t p s : / / …, чтобы фильтр не распознал URL.

Итого
Посетитель пишет что хочет;

Вы проверяете и чистите текст до fetch;

Formspree получает уже «безопасное» письмо без триггеров, и Formshield не цепляет его.

Таким образом «следить» вы будете скриптом, а не вручную, и при этом останетесь на бесплатном тарифе.








































